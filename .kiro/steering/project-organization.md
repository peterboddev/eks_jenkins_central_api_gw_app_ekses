---
inclusion: auto
---

# Project Organization Standards - Steering Rules

## Build Artifacts Location Standard

**CRITICAL RULE**: All build artifacts (zip files, compiled binaries, generated files) MUST be placed in the `tmp/` subdirectory of the feature/component that uses them.

### Directory Structure Pattern

```
{component-name}/
├── tmp/                    # Build artifacts (auto-generated, gitignored)
│   ├── *.zip              # Zip files
│   ├── *.jar              # Compiled JARs
│   └── *.generated.*      # Any generated files
├── src/                   # Source code
├── package.json           # Dependencies
└── README.md              # Documentation
```

### Examples

#### ✅ Correct

```
nginx-api/tmp/kubectl-layer.zip          # Used by nginx-api-cluster stack
jenkins-jobs/tmp/job-configs.zip         # Used by Jenkins deployment
lambda-functions/tmp/deployment.zip      # Used by Lambda deployment
```

#### ❌ Incorrect

```
kubectl-layer.zip                        # At project root - unclear ownership
build/kubectl-layer.zip                  # Non-standard directory name
nginx-api/kubectl-layer.zip              # Not in tmp/ subdirectory
```

## Implementation Rules

### When Creating Build Scripts

1. **Output Location**: Always output to `{component}/tmp/`
   ```javascript
   const outputPath = path.join(__dirname, '..', 'nginx-api', 'tmp', 'output.zip');
   ```

2. **Create tmp/ Directory**: Ensure directory exists before writing
   ```javascript
   if (!fs.existsSync(tmpDir)) {
     fs.mkdirSync(tmpDir, { recursive: true });
   }
   ```

3. **Check Existing Files**: Skip generation if file already exists (performance)
   ```javascript
   if (fs.existsSync(outputPath)) {
     console.log('✓ File already exists');
     process.exit(0);
   }
   ```

### When Referencing Build Artifacts

1. **Use Full Relative Path**: Make it clear where the file is
   ```typescript
   // ✅ Good
   lambda.Code.fromAsset('nginx-api/tmp/kubectl-layer.zip')
   
   // ❌ Bad
   lambda.Code.fromAsset('kubectl-layer.zip')
   ```

2. **Document the Dependency**: Comment why this path is used
   ```typescript
   // Use kubectl layer from nginx-api component
   // Generated by: npm run prepare-kubectl-layer
   const kubectlLayer = lambda.Code.fromAsset('nginx-api/tmp/kubectl-layer.zip');
   ```

### When Adding to package.json

1. **Use prebuild Hook**: Auto-generate before build
   ```json
   {
     "scripts": {
       "prepare-{artifact}": "node scripts/prepare-{artifact}.js",
       "prebuild": "npm run prepare-{artifact}",
       "build": "tsc"
     }
   }
   ```

2. **Name Scripts Clearly**: Use `prepare-{artifact-name}` pattern
   ```json
   {
     "scripts": {
       "prepare-kubectl-layer": "node scripts/prepare-kubectl-layer.js",
       "prepare-lambda-zip": "node scripts/prepare-lambda-zip.js"
     }
   }
   ```

## .gitignore Standard

The project uses a single global pattern to exclude all tmp/ directories:

```gitignore
# Temporary build artifacts
tmp/
```

**DO NOT** add specific file patterns like:
- ❌ `kubectl-layer.zip`
- ❌ `nginx-api/tmp/kubectl-layer.zip`
- ❌ `*/tmp/*.zip`

The `tmp/` pattern catches everything automatically.

## Why This Standard?

### Benefits

1. **Clear Ownership**: Artifact location shows which component uses it
2. **Modular Organization**: Each component manages its own artifacts
3. **Easy Cleanup**: `rm -rf */tmp` cleans all temporary files
4. **Standard Convention**: Developers expect `tmp/` to be temporary
5. **Scalable**: Works for any number of components
6. **No .gitignore Maintenance**: Single pattern covers all cases

### Prevents Issues

1. **No Root Clutter**: Project root stays clean
2. **No Confusion**: Clear which component owns each artifact
3. **No Git Bloat**: All artifacts automatically ignored
4. **No Merge Conflicts**: Generated files never committed

## Checklist for New Build Artifacts

When adding a new build artifact to the project:

- [ ] Identify which component uses this artifact
- [ ] Create `{component}/tmp/` directory if it doesn't exist
- [ ] Update build script to output to `{component}/tmp/{artifact-name}`
- [ ] Add prebuild hook to package.json if needed
- [ ] Update code references to use full path: `{component}/tmp/{artifact-name}`
- [ ] Test: `npm run build` should auto-generate the artifact
- [ ] Verify: `git status` should NOT show the artifact (it's in tmp/)
- [ ] Document: Add comment explaining what generates this artifact

## Common Scenarios

### Scenario 1: Lambda Deployment Package

```bash
# Component: lambda-functions/
# Artifact: deployment.zip
# Location: lambda-functions/tmp/deployment.zip
# Generated by: scripts/prepare-lambda-deployment.js
# Used by: lib/lambda-stack.ts
```

### Scenario 2: Kubernetes Manifests Bundle

```bash
# Component: k8s/
# Artifact: manifests.tar.gz
# Location: k8s/tmp/manifests.tar.gz
# Generated by: scripts/bundle-manifests.js
# Used by: deployment scripts
```

### Scenario 3: Docker Build Context

```bash
# Component: nginx-api/
# Artifact: build-context.zip
# Location: nginx-api/tmp/build-context.zip
# Generated by: scripts/prepare-docker-context.js
# Used by: Docker build process
```

## Migration from Non-Standard Locations

If you find build artifacts in non-standard locations:

1. **Identify the component**: Which component uses this artifact?
2. **Create tmp/ directory**: `mkdir -p {component}/tmp`
3. **Update generation script**: Change output path to `{component}/tmp/`
4. **Update references**: Change code to reference new path
5. **Test build**: Run `npm run build` and verify it works
6. **Clean up**: Delete artifact from old location
7. **Verify git**: Run `git status` - artifact should not appear

## Related Documentation

- `docs/guides/PROJECT_ORGANIZATION.md` - Detailed project organization guide
- `docs/guides/KUBECTL_LAYER_AUTOMATION.md` - Example implementation
- `docs/guides/BINARY_FILES_CLEANUP.md` - Why binaries don't belong in git

## Summary

**Golden Rule**: Build artifacts go in `{component}/tmp/{artifact-name}`, nowhere else.

This keeps the project organized, maintainable, and scalable.
